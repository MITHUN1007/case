
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { prompt, complexity, minNodes, maxNodes, smartCredentials } = await req.json();
    
    console.log('ü§ñ Generating complex workflow with Gemini API:', {
      prompt: prompt?.substring(0, 100),
      complexity,
      minNodes,
      maxNodes,
      smartCredentials
    });

    const GEMINI_API_KEY = 'AIzaSyCuBM4mVKy_Tx8oMcpFw-2BUG3h22JvXyM';
    
    const geminiPrompt = `Generate a complex n8n workflow JSON with ${minNodes}-${maxNodes} nodes for: ${prompt}

Requirements:
- Create a complete n8n workflow with interconnected nodes
- Include realistic node types like webhook, httpRequest, code, if, set, emailSend, slack, etc.
- Add proper connections between nodes
- Include realistic parameters for each node
- Make it production-ready with error handling
- Add unique UUIDs for each node
- Include proper positioning for visual layout

Return ONLY valid JSON in this exact format:
{
  "name": "Workflow Name",
  "description": "Brief description",
  "nodes": [
    {
      "id": "unique-uuid",
      "name": "Node Name",
      "type": "n8n-nodes-base.nodetype",
      "typeVersion": 1,
      "position": [x, y],
      "parameters": {}
    }
  ],
  "connections": {
    "Node Name": {
      "main": [[{"node": "Next Node Name", "type": "main", "index": 0}]]
    }
  },
  "settings": {
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "executionTimeout": 3600,
    "timezone": "UTC"
  },
  "staticData": {},
  "active": false
}`;

    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: geminiPrompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 8192,
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Gemini API error: ${response.status}`);
    }

    const data = await response.json();
    console.log('üì• Gemini API response received');

    if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
      throw new Error('No content generated by Gemini');
    }

    let generatedText = data.candidates[0].content.parts[0].text;
    
    // Clean up the JSON response
    generatedText = generatedText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    let workflow;
    try {
      workflow = JSON.parse(generatedText);
    } catch (parseError) {
      console.error('‚ùå Failed to parse workflow JSON:', parseError);
      throw new Error('Generated workflow is not valid JSON');
    }

    // Add UUIDs if missing
    if (workflow.nodes) {
      workflow.nodes = workflow.nodes.map((node: any) => ({
        ...node,
        id: node.id || crypto.randomUUID(),
        webhookId: node.type === 'n8n-nodes-base.webhook' ? crypto.randomUUID() : undefined
      }));
    }

    // Detect credential nodes
    const credentialNodes = workflow.nodes?.filter((node: any) => {
      const credentialTypes = [
        'n8n-nodes-base.telegram',
        'n8n-nodes-base.slack',
        'n8n-nodes-base.youtube',
        'n8n-nodes-base.openAi',
        'n8n-nodes-base.anthropic',
        'n8n-nodes-base.gmail',
        'n8n-nodes-base.googleSheets'
      ];
      return credentialTypes.includes(node.type);
    }) || [];

    console.log('‚úÖ Complex workflow generated successfully:', {
      nodeCount: workflow.nodes?.length || 0,
      credentialNodesCount: credentialNodes.length,
      workflowName: workflow.name
    });

    return new Response(JSON.stringify({
      success: true,
      response: `Generated ${workflow.nodes?.length || 0}-node complex workflow: "${workflow.name}"`,
      workflow: workflow,
      workflowJson: JSON.stringify(workflow, null, 2),
      credentialNodes: credentialNodes,
      modelUsed: 'Gemini 2.0 Flash'
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });

  } catch (error) {
    console.error('‚ùå Error in generate-complex-workflow:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || 'Unknown error occurred'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
